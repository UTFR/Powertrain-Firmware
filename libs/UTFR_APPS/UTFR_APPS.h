#include "MCP_DAC.h"
#include "lib_util.h"

#ifndef _UTFR_APPS_H_
#define _UTFR_APPS_H_

//#define debugMode         // Uncomment this line to enable debug prints

#define GET_DEV(x, y) abs((x-y)/(x+0.0001))

class UTFR_APPS {                      

    public:

        UTFR_APPS(uint8_t dataOut = 255, uint8_t clock = 255);
        void begin(int CS);
        void processThrottlePosition();
        void shutDown();
        bool getShutdownState();                // returns true if shutdown() function has been called        
        bool confirmShutdown();                 // returns true if output of DAC is 0

    private:

        MCP4911 DAC;                                    // UTFR_APPS contains our DAC object (UTFR_APPS is now a composite class)

                                                        // "Composite" simply means it has a member which is an object of another class type (MCP4911 here)
                                                            // Composition helps avoid multiple inheritance
                                                            // Multiple inheritance is dangerous - can lead to the diamond problem 
                                                            // Multiple inheritance is slow (chains of function pointers in compiled program) 
                                                            // Multiple inheritance takes up more space (Function lookup tables generated by compiler) 
                                                            
                                                        // Therefore, Composition is advantageous over inheritance for safety and performance reasons

        const int _kANALOG_MAX = 1023;
        const float _kAPPS_1_HIGH = 4.75;     
        const float _kAPPS_2_HIGH = 4.75;      
        const float _kAPPS_1_LOW = 1.25;       
        const float _kAPPS_2_LOW = 1.25;      

        const uint8_t _kTIME_ALLOWANCE = 100;           // DO NOT CHANGE: Maximum error time allowed by rules; milliseconds
        const float _kTHROTTLE_MAX_DEVIATION = 0.10;    // DO NOT CHANGE: Rule T.4.2.4
        const float _kBRAKE_THRESHOLD = 2.5;           // (units of V) determine experimentally
        const float _kBRAKE_DEVIATION = 0.25;          // DO NOT CHANGE: Rule EV.5.7.1
        const float _kOUTPUT_DEVIATION = 0.03;          // ** TO DO: Determine **
        const int _kBASE_TIME = -1; 
        const uint8_t _confirm_shutdown_retries = 20;

        float _APPS_1_high = 0.0;            // These will be the digital conversions of the constant voltage values above        
        float _APPS_2_high = 0.0;            // Used to calculate APPS_output
        float _APPS_1_low = 0.0;
        float _APPS_2_low = 0.0; 
        float _Brake_threshold = 0.0;

        int _DAC_CS = 7;
        float _Brake_in = 0;
        float _APPS_1_in = 0;
        float _APPS_2_in = 0;                             // 0 - 1023
        int _APPS_output = 0;
        int _APPS_out_verify = 0;                       // 0 - 1023
        float _APPS_1_throttle = 0.0;
        float _APPS_2_throttle = 0.0;
        long _time_at_error = _kBASE_TIME;              // unsigned long type according to arduino docs, not sure about this
        unsigned long _time_now = 0;

        bool _throttle_good = false;
        bool _output_good = false;
        bool _exceed_time_allowance = false;
        bool _error_flag_set = false;
        bool _brakes_good = false;


        bool _shutdown = false;

        void sendOutput(void);
        void reportError(void);
        int roundOutput(float value);
        float getDigital(float voltage);                // gets 10-bit digital representation of voltage

};

#endif