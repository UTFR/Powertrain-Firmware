#include "MCP_DAC.h"
#include "UTFR_PIN_DRIVER_MICRO.h"
#include "lib_util.h"

#ifndef _UTFR_APPS_H_
#define _UTFR_APPS_H_

#define debug_APPS         // Uncomment this line to enable debug prints

#define GET_DEV(x, y) abs(2*(x-y)/(x+y+0.0001))

#define kAPPS_OUTPUT_ARRAY_SIZE     8
#define kLOW_PASS_WINDOW            4

class UTFR_APPS {                      

    public:

        UTFR_APPS(uint8_t dataOut = 255, uint8_t clock = 255);
        void begin(int CS);
        void processThrottlePosition();
        void shutdown();                        // Called when implausibility check failed for >100ms, cannot exit this state


    private:

        MCP4911 DAC;                                    // UTFR_APPS contains our DAC object (UTFR_APPS is now a composite class)

                                                        // "Composite" simply means it has a member which is an object of another class type (MCP4911 here)
                                                            // Composition helps avoid multiple inheritance
                                                            // Multiple inheritance is dangerous - can lead to the diamond problem 
                                                            // Multiple inheritance is slow (chains of function pointers in compiled program) 
                                                            // Multiple inheritance takes up more space (Function lookup tables generated by compiler) 
                                                            
                                                        // Therefore, Composition is advantageous over inheritance for safety and performance reasons

        const int _kANALOG_MAX = 1023;

        const uint8_t _kTIME_ALLOWANCE = 100;               // DO NOT CHANGE: Maximum error time allowed by rules; milliseconds
        const float _kTHROTTLE_MAX_DEVIATION = 0.10;        // DO NOT CHANGE: Rule T.4.2.4
        const float _kBRAKE_THRESHOLD = 200;                // TO DO: calibrate pedal input (EV.5.7.1)
        const float _kTHROTTLE_WHILE_BRAKE_LIMIT = 0.25;    // DO NOT CHANGE: Rule EV.5.7.1
        const float _kOUTPUT_MAX_DEVIATION = 0.10;          // TO DO: calibrate
        const int _kBASE_TIME = -1; 
        const uint8_t _confirm_shutdown_retries = 20;

        float _APPS_1_high = 750.0;                
        float _APPS_2_high = 700.0;            
        float _APPS_1_low = 5.0;
        float _APPS_2_low = 26.0; 
        float _Brake_threshold = 0;

        float _Brake_in = 0;
        float _APPS_1_in = 0;
        float _APPS_2_in = 0;                             // 0 - 1023
        int _APPS_output = 0;

        int _APPS_output_array[kAPPS_OUTPUT_ARRAY_SIZE]; //Output window
        int _APPS_output_idx = 0;

        int _APPS_out_verify = 0;                       // 0 - 1023
        float _APPS_1_throttle = 0.0;
        float _APPS_2_throttle = 0.0;
        long _time_at_error = _kBASE_TIME;              // unsigned long type according to arduino docs, not sure about this
        unsigned long _time_now = 0;

        bool _throttle_good = false;
        bool _output_good = false;
        bool _exceed_time_allowance = false;
        bool _error_flag_set = false;
        bool _brake_and_throttle = false;               // True to disable outputs temporarily when brake and throttle pressed

        bool _shutdown = false;                         // Flipped to disable outputs permenantly when pedal implausibility                   

        void sendOutput(void);
        void reportError(void);
};

#endif